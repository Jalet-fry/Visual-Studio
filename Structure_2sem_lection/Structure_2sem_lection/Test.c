#include <stdio.h>
#include <string.h>
void print_with_replacement(char *str) {
    // Проходим по каждому символу в строке
    for (int i = 0; i < strlen(str); i++) {
        // В зависимости от символа, выводим соответствующую замену
        switch (str[i]) {
            case '0':
                printf("11");
                break;
            case '1':
                printf("10");
                break;
            case '2':
                printf("00");
                break;
            case '3':
                printf("01");
                break;
            default:
                // Если символ не 0 1 2 3, то просто выводим его без изменений
                printf("%c", str[i]);
                break;
        }
    }
    // Переводим строку на новую строку
    printf("\n");
}
//int main() {
//    char test_str[] = "0103100 000000 ";
//    char* text[] = ("0103100 000000", "0000000 000000", "0103100 000000", "0103100 000000", "0021220 000000", "0130320 000000", "3332303 000000", "0123223 000000", "0000212 200000", "0130101 200000", "3333323 030000", "0130030 230000", "0000000 000000", "0130030 230000");
//    print_with_replacement("0000000 000000");
//    print_with_replacement("0103100 000000");
//    print_with_replacement("0103100 000000");
//    print_with_replacement("0021220 000000");
//    print_with_replacement("0130320 000000");
//    print_with_replacement("3332303 000000");
//    print_with_replacement("0123223 000000");
//    print_with_replacement("0000212 200000");
//    print_with_replacement("0130101 200000");
//    print_with_replacement("3333323 030000");
//    print_with_replacement("0130030 230000");
//    print_with_replacement("0000000 000000");
//    print_with_replacement("0130030 230000");
//    for (int i = -200; i < 220; i++) {
//        printf("%c = %d\n", i, i);
//        
//    }
//
//
//    ////print_with_replacement("0021220 000000");
//    ////print_with_replacement("0130320 000000 ");
//    ////print_with_replacement("3332303 000000 ");
//    ////print_with_replacement("0123223 000000 ");
//    ////print_with_replacement("0000212 200000 ");
//    ////print_with_replacement("0130101 200000 ");
//    ////print_with_replacement("3333323 030000 ");
//    // Вывод: 111001011100 111111 
//    return 0;
//}
///////////int utf8_len(unsigned char byte) {
///////////  if (byte <= 0x7F) return 1; // 1 байт, 7 бит
///////////  if (byte >= 0xC0 && byte <= 0xDF) return 2; // 2 байта, 11 бит
///////////  if (byte >= 0xE0 && byte <= 0xEF) return 3; // 3 байта, 16 бит
///////////  if (byte >= 0xF0 && byte <= 0xF7) return 4; // 4 байта, 21 бит
///////////  return 0; // неверный байт
///////////}
///////////
///////////// Функция, которая преобразует UTF-8 символ в кодовую точку Unicode
///////////unsigned int utf8_to_codepoint(unsigned char *bytes, int len) {
///////////  unsigned int codepoint = 0;
///////////  if (len == 1) {
///////////    codepoint = bytes[0];
///////////  } else if (len == 2) {
///////////    codepoint = ((bytes[0] & 0x1F) << 6) | (bytes[1] & 0x3F);
///////////  } else if (len == 3) {
///////////    codepoint = ((bytes[0] & 0x0F) << 12) | ((bytes[1] & 0x3F) << 6) | (bytes[2] & 0x3F);
///////////  } else if (len == 4) {
///////////    codepoint = ((bytes[0] & 0x07) << 18) | ((bytes[1] & 0x3F) << 12) | ((bytes[2] & 0x3F) << 6) | (bytes[3] & 0x3F);
///////////  }
///////////  return codepoint;
///////////}
///////////
///////////// Функция, которая преобразует кодовую точку Unicode в UTF-8 символ
///////////void codepoint_to_utf8(unsigned int codepoint, unsigned char *bytes, int *len) {
///////////  if (codepoint <= 0x7F) {
///////////    bytes[0] = codepoint;
///////////    *len = 1;
///////////  } else if (codepoint <= 0x7FF) {
///////////    bytes[0] = 0xC0 | ((codepoint >> 6) & 0x1F);
///////////    bytes[1] = 0x80 | (codepoint & 0x3F);
///////////    *len = 2;
///////////  } else if (codepoint <= 0xFFFF) {
///////////    bytes[0] = 0xE0 | ((codepoint >> 12) & 0x0F);
///////////    bytes[1] = 0x80 | ((codepoint >> 6) & 0x3F);
///////////    bytes[2] = 0x80 | (codepoint & 0x3F);
///////////    *len = 3;
///////////  } else if (codepoint <= 0x10FFFF) {
///////////    bytes[0] = 0xF0 | ((codepoint >> 18) & 0x07);
///////////    bytes[1] = 0x80 | ((codepoint >> 12) & 0x3F);
///////////    bytes[2] = 0x80 | ((codepoint >> 6) & 0x3F);
///////////    bytes[3] = 0x80 | (codepoint & 0x3F);
///////////    *len = 4;
///////////  }
///////////}
///////////#include <stdio.h>
///////////#include <string.h>
///////////#include <stdlib.h>
///////////#include <ctype.h>
///////////
///////////// Функции utf8_len, utf8_to_codepoint и codepoint_to_utf8 остаются без изменений
///////////
///////////// Функция, которая шифрует текст в шифр Цезаря
///////////void cipher(FILE *file, int k, int alphabet_size) {
///////////  if (k == 0) {
///////////    printf("Нет ключа для шифрования\n");
///////////    return;
///////////  }
///////////  int file_length = 0; // длина файла в байтах
///////////  int encrypted_file_length = 0; // длина зашифрованного файла в байтах
///////////  unsigned char *file_content = NULL; // содержимое файла в байтах
///////////  unsigned char *encrypted_file_content = NULL; // содержимое зашифрованного файла в байтах
///////////
///////////  // Считываем содержимое файла в байтах
///////////  fseek(file, 0, SEEK_END); // перемещаемся в конец файла
///////////  file_length = ftell(file); // получаем длину файла в байтах
///////////  fseek(file, 0, SEEK_SET); // перемещаемся в начало файла
///////////  file_content = malloc(sizeof(unsigned char) * file_length); // выделяем память для содержимого файла
///////////  fread(file_content, sizeof(unsigned char), file_length, file); // считываем содержимое файла в байтах
///////////
///////////  // Шифруем содержимое файла в байтах
///////////  encrypted_file_content = malloc(sizeof(unsigned char) * file_length); // выделяем память для зашифрованного содержимого файла
///////////  int i = 0; // индекс в исходном файле
///////////  int j = 0; // индекс в зашифрованном файле
///////////  while (i < file_length) {
///////////    unsigned char byte = file_content[i]; // текущий байт
///////////    int len = utf8_len(byte); // длина UTF-8 символа
///////////    if (len == 0) {
///////////      printf("Неверный UTF-8 символ\n");
///////////      free(file_content);
///////////      free(encrypted_file_content);
///////////      return;
///////////    }
///////////    unsigned char bytes[4]; // байты UTF-8 символа
///////////    for (int n = 0; n < len; n++) {
///////////      bytes[n] = file_content[i + n];
///////////    }
///////////    unsigned int codepoint = utf8_to_codepoint(bytes, len); // кодовая точка Unicode
///////////
///////////    if (isalpha(codepoint)) { // если символ является буквой
///////////      int is_upper = isupper(codepoint); // если символ является заглавной буквой
///////////      codepoint = tolower(codepoint); // преобразуем символ в строчную букву
///////////      codepoint += k; // прибавляем к символу ключ шифрования
///////////      if (codepoint > 'z') { // если символ вышел за пределы английского алфавита
///////////        codepoint -= 26; // вычитаем из него количество букв в английском алфавите
///////////      } else if (codepoint > 'я') { // если символ вышел за пределы русского алфавита
///////////        codepoint -= 32; // вычитаем из него количество букв в русском алфавите
///////////      }
///////////      if (is_upper) { // если символ был заглавной буквой
///////////        codepoint = toupper(codepoint); // преобразуем символ в заглавную букву
///////////      }
///////////    }
///////////
///////////    codepoint_to_utf8(codepoint, bytes, &len); // преобразуем кодовую точку обратно в UTF-8 символ
///////////    for (int n = 0; n < len; n++) {
///////////      encrypted_file_content[j + n] = bytes[n];
///////////    }
///////////    i += len; // переходим к следующему UTF-8 символу в исходном файле
///////////    j += len; // переходим к следующему UTF-8 символу в зашифрованном файле
///////////  }
///////////
///////////  encrypted_file_length = j; // получаем длину зашифрованного файла в байтах
///////////
///////////  // Записываем зашифрованное содержимое файла в байтах
///////////  fseek(file, 0, SEEK_SET); // перемещаемся в начало файла
///////////  fwrite(encrypted_file_content, sizeof(unsigned char), encrypted_file_length, file); // записываем зашифрованное содержимое файла в байтах
///////////  ftruncate(fileno(file), encrypted_file_length); // обрезаем файл до длины зашифрованного содержимого
///////////
///////////  // Освобождаем память и закрываем файл
///////////  free(file_content);
///////////  free(encrypted_file_content);
///////////  fclose(file);
///////////}
///////////
///////////int main(int argc, char *argv[]) {
///////////  if (argc != 2) {
///////////    printf("Неверное количество аргументов\n");
///////////    return 1;
///////////  }
///////////  char *file_path = argv[1]; // путь к файлу
///////////  int k = 1; // ключ шифрования
///////////  int alphabet_size = 26; // количество букв в английском алфавите
///////////  FILE *file = fopen(file_path, "rb+"); // открываем файл для чтения и записи в бинарном режиме
///////////  if (file == NULL) {
///////////    printf("Не удалось открыть файл\n");
///////////    return 2;
///////////  }
///////////  cipher(file, k, alphabet_size); // шифруем файл
///////////  return 0;
///////////}
////////////////////////////////////////#include <stdio.h>
////////////////////////////////////////#include <string.h>
////////////////////////////////////////#include <stdlib.h>
////////////////////////////////////////
////////////////////////////////////////// Функция, которая шифрует текст в шифр Цезаря
////////////////////////////////////////void cipher(FILE *file, int k, int lower, int upper) {
////////////////////////////////////////  if (k == 0) {
////////////////////////////////////////    printf("Нет ключа для шифрования\n");
////////////////////////////////////////    return;
////////////////////////////////////////  }
////////////////////////////////////////  int alphabet_size = upper - lower + 1; // размер алфавита
////////////////////////////////////////  int file_length = 0; // длина файла в байтах
////////////////////////////////////////  int encrypted_file_length = 0; // длина зашифрованного файла в байтах
////////////////////////////////////////  char *file_content = NULL; // содержимое файла в символах
////////////////////////////////////////  char *encrypted_file_content = NULL; // содержимое зашифрованного файла в символах
////////////////////////////////////////
////////////////////////////////////////  // Считываем содержимое файла в символах
////////////////////////////////////////  fseek(file, 0, SEEK_END); // перемещаемся в конец файла
////////////////////////////////////////  file_length = ftell(file); // получаем длину файла в байтах
////////////////////////////////////////  fseek(file, 0, SEEK_SET); // перемещаемся в начало файла
////////////////////////////////////////  file_content = malloc(sizeof(char) * file_length); // выделяем память для содержимого файла
////////////////////////////////////////  fread(file_content, sizeof(char), file_length, file); // считываем содержимое файла в символах
////////////////////////////////////////
////////////////////////////////////////  // Шифруем содержимое файла в символах
////////////////////////////////////////  encrypted_file_content = malloc(sizeof(char) * file_length); // выделяем память для зашифрованного содержимого файла
////////////////////////////////////////  for (int i = 0; i < file_length; i++) {
////////////////////////////////////////    char symbol = file_content[i]; // текущий символ
////////////////////////////////////////    if (symbol >= lower && symbol <= upper) { // если символ входит в диапазон
////////////////////////////////////////      symbol += k; // прибавляем к символу ключ шифрования
////////////////////////////////////////      if (symbol > upper) { // если символ вышел за пределы диапазона
////////////////////////////////////////        symbol -= alphabet_size; // вычитаем из него размер алфавита
////////////////////////////////////////      }
////////////////////////////////////////    }
////////////////////////////////////////    encrypted_file_content[i] = symbol; // записываем символ в зашифрованное содержимое
////////////////////////////////////////  }
////////////////////////////////////////
////////////////////////////////////////  encrypted_file_length = file_length; // длина зашифрованного файла равна длине исходного файла
////////////////////////////////////////
////////////////////////////////////////  // Записываем зашифрованное содержимое файла в символах
////////////////////////////////////////  fseek(file, 0, SEEK_SET); // перемещаемся в начало файла
////////////////////////////////////////  fwrite(encrypted_file_content, sizeof(char), encrypted_file_length, file); // записываем зашифрованное содержимое файла в символах
////////////////////////////////////////
////////////////////////////////////////  // Освобождаем память и закрываем файл
////////////////////////////////////////  free(file_content);
////////////////////////////////////////  free(encrypted_file_content);
////////////////////////////////////////  fclose(file);
////////////////////////////////////////}
////////////////////////////////////////
////////////////////////////////////////int main(int argc, char* argv[]) {
////////////////////////////////////////    if (argc != 2) {
////////////////////////////////////////        printf("Неверное количество аргументов\n");
////////////////////////////////////////        return 1;
////////////////////////////////////////    }
////////////////////////////////////////    char* file_path = argv[1]; // путь к файлу
////////////////////////////////////////    int k = 1; // ключ шифрования
////////////////////////////////////////    int lower = 65; // нижняя граница диапазона кодов символов
////////////////////////////////////////    int upper = 255; // верхняя граница диапазона кодов символов
////////////////////////////////////////    FILE* file = fopen(file_path, "r+"); // открываем файл для чтения и записи
////////////////////////////////////////    if (file == NULL) {
////////////////////////////////////////        printf("Не удалось открыть файл\n");
////////////////////////////////////////        return 2;
////////////////////////////////////////    }
////////////////////////////////////////    cipher(file, k, lower, upper); // шифруем файл
////////////////////////////////////////    char i[] = "\320\237\321\200\320\270\320\262\320\265\321\202"; // текст "Привет" в кодировке UTF-8.
////////////////////////////////////////    char j[] = "\317\360\350\342\345\362"; // текст "Привет" в кодировке Windows-1251.
////////////////////////////////////////    char l[] = "\360\322\311\327\305\324"; // текст "Привет" в кодировке KOI-8R.
////////////////////////////////////////    char m[] = "\277\340\330\322\325\342"; // текст "Привет" в кодировке ISO-8859-5.
////////////////////////////////////////    char n[] = "Привет";                   // текст "Привет" в кодировке файла скетча.
////////////////////////////////////////    printf("%s\n%s\n%s\n%s\n%s\n", i, j, l,m,n);
////////////////////////////////////////    return 0;
////////////////////////////////////////}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <wchar.h>

// Функция, которая шифрует или расшифровывает строку в заданной кодировке
/////////////char* caesar_cipher(char* str, int key, char* encoding) {
/////////////    setlocale(LC_ALL, encoding);
/////////////
/////////////    // Выделяем память для результирующей строки
/////////////    char* result = (char*)malloc(strlen(str) + 1);
/////////////
/////////////    // Объявляем переменные для работы с символами
/////////////    int index = 0; // индекс в исходной строке
/////////////    int offset = 0; // смещение в результирующей строке
/////////////    int bytes = 0; // количество байтов в символе
/////////////    wint_t code = 0; // код широкого символа
/////////////    wchar_t wc = 0; // широкий символ
/////////////    char c = 0; // обычный символ
/////////////    unsigned char uc = 0; // беззнаковый символ
/////////////
/////////////    // Пока не достигнем конца строки
/////////////    while (str[index] != '\0') {
/////////////        // Если кодировка UTF-8
/////////////        if (strcmp(encoding, ".UTF8") == 0) {
/////////////            // Преобразуем многобайтовый символ в широкий символ
/////////////            bytes = mbtowc(&wc, &str[index], strlen(str) - index);
/////////////
/////////////            // Проверяем, что преобразование успешно
/////////////            if (bytes == -1) {
/////////////                printf("Ошибка преобразования\n");
/////////////                exit(1);
/////////////            }
/////////////
/////////////            // Получаем код широкого символа
/////////////            code = wc;
/////////////
/////////////            // Если символ - буква русского алфавита
/////////////            if ((code >= L'А' && code <= L'Я') || (code >= L'а' && code <= L'я')) {
/////////////                // Сдвигаем его на ключ по модулю 32, учитывая регистр и начало алфавита
/////////////                if (code >= L'А' && code <= L'Я') {
/////////////                    code = (code - L'А' + key) % 32 + L'А';
/////////////                } else {
/////////////                    code = (code - L'а' + key) % 32 + L'а';
/////////////                }
/////////////            }
/////////////
/////////////            // Если символ - буква английского алфавита
/////////////            if ((code >= L'A' && code <= L'Z') || (code >= L'a' && code <= L'z')) {
/////////////                // Сдвигаем его на ключ по модулю 26, учитывая регистр и начало алфавита
/////////////                if (code >= L'A' && code <= L'Z') {
/////////////                    code = (code - L'A' + key) % 26 + L'A';
/////////////                } else {
/////////////                    code = (code - L'a' + key) % 26 + L'a';
/////////////                }
/////////////            }
/////////////
/////////////            // Преобразуем широкий символ в многобайтовый символ
/////////////            bytes = wctomb(&result[offset], code);
/////////////
/////////////            // Проверяем, что преобразование успешно
/////////////            if (bytes == -1) {
/////////////                printf("Ошибка преобразования\n");
/////////////                exit(1);
/////////////            }
/////////////        }
/////////////
/////////////        // Если кодировка windows1251
/////////////        if (strcmp(encoding, ".1251") == 0) {
/////////////            // Приводим символ к беззнаковому типу
/////////////            uc = (unsigned char)str[index];
/////////////
/////////////            // Если символ - буква русского алфавита
/////////////            if ((uc >= 192 && uc <= 223) || (uc >= 224 && uc <= 255)) {
/////////////                // Сдвигаем его на ключ по модулю 32, учитывая регистр и начало алфавита
/////////////                if (uc >= 192 && uc <= 223) {
/////////////                    uc = (uc - 192 + key) % 32 + 192;
/////////////                } else {
/////////////                    uc = (uc - 224 + key) % 32 + 224;
/////////////                }
/////////////            }
/////////////
/////////////            // Если символ - буква английского алфавита
/////////////            if ((uc >= 65 && uc <= 90) || (uc >= 97 && uc <= 122)) {
/////////////                // Сдвигаем его на ключ по модулю 26, учитывая регистр и начало алфавита
/////////////                if (uc >= 65 && uc <= 90) {
/////////////                    uc = (uc - 65 + key) % 26 + 65;
/////////////                } else {
/////////////                    uc = (uc - 97 + key) % 26 + 97;
/////////////                }
/////////////            }
/////////////
/////////////            // Приводим символ к обычному типу
/////////////            c = (char)uc;
/////////////
/////////////            // Копируем символ в результирующую строку
/////////////            result[offset] = c;
/////////////
/////////////            // Устанавливаем количество байтов в символе равным 1
/////////////            bytes = 1;
/////////////        }
/////////////
/////////////        // Увеличиваем индекс и смещение на количество байтов в символе
/////////////        index += bytes;
/////////////        offset += bytes;
/////////////    }
/////////////
/////////////    // Завершаем результирующую строку нулевым символом
/////////////    result[offset] = '\0';
/////////////
/////////////    // Возвращаем результирующую строку из функции
/////////////    return result;
/////////////}
/////////////
/////////////int main(void) {
/////////////    // Объявляем и инициализируем переменные для хранения строки, ключа и кодировки
/////////////    char* str = "ABCDefg абвГДе";
/////////////    int key = 1;
/////////////    //char* encoding = ".UTF8";
/////////////    char* encoding = ".1251";
/////////////
/////////////    // Выделяем память для хранения строки и кодировки
/////////////    str = (char*)malloc(100);
/////////////    encoding = (char*)malloc(10);
/////////////
/////////////    ////`// Считываем строку, ключ и кодировку с клавиатуры
/////////////    ////`printf("Введите строку: ");
/////////////    ////`scanf("%s", str);
/////////////    ////`printf("Введите ключ: ");
/////////////    ////`scanf("%d", &key);
/////////////    ////`printf("Введите кодировку (.UTF8 или .1251): ");
/////////////    ////`scanf("%s", encoding);
/////////////
/////////////    // Вызываем функцию шифрования и выводим результат на экран
/////////////    printf("Зашифрованная строка: %s\n", caesar_cipher(str, key, encoding));
/////////////
/////////////    // Вызываем функцию расшифрования и выводим результат на экран
/////////////}
